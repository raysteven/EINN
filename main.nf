// main.nf (simplified with corrected workflow)
nextflow.enable.dsl = 2

// --- Parameters ---
params.input_base = "${projectDir}/data"
params.outdir     = "results"
params.ec_params  = 'params.csv'
params.license    = "."

// TWO different Biolog files for ALIGNMENT
params.biolog_csv_ec = "${projectDir}/data/biolog/biolog_iML1515_ec_EXP.csv"  // For ec model alignment
params.biolog_csv_conv = "${projectDir}/data/biolog/biolog_iML1515_EXP.csv"    // For conventional model alignment

// TWO different Medium files for TRAINING SET GENERATION
params.medium_csv_ec = "${projectDir}/data/biolog/iML1515_ec_EXP.csv"          // For ec model training set
params.medium_csv_conv = "${projectDir}/data/biolog/iML1515_EXP.csv"            // For conventional model training set

params.uniprot_file = "${projectDir}/data/uniprotkb_taxonomy_id_83333_2025_10_14.tsv.gz"

// Training parameters (defaults, can be overridden)
params.epochs = 20
params.folds = 5
params.inner_loops = 1
params.outer_loops = 200
params.timestep = 4
params.mediumbound = "UB"  // Default medium bound

// Project list: [ID, Input Folder, C_Source_Value, Conv_Model_Filename]
project_list = [
    ['eciAF1260', 'input_data_eciAF1260', -13.34, 'iAF1260.xml'],
    ['eciML1515', 'input_data_eciML1515', -9.65, 'iML1515.xml']
]

process GECKO_PIPELINE {
    tag "${project_id}"

    input:
    tuple val(project_id), path(input_path), val(c_val), path(conv_model_file)
    val ec_params
    path gurobi_lic

    output:
    tuple val(project_id), 
          path("${project_id}_raw.xml"), 
          path("${project_id}_conv.xml"),
          path("${project_id}_kcats.csv"),
          path("${project_id}_ecFVA.csv")

    script:
    """
    export GRB_LICENSE_FILE=\$(readlink -f ${gurobi_lic})

    matlab -nodisplay -nosplash -batch "maxNumCompThreads(6); addpath(genpath('${projectDir}')); rehash; gecko_protocol('project_name','${project_id}','input_folder','${input_path}','ec_params','${ec_params}','c_source_val',${c_val});"
    
    # Move the new ecModel
    mv ${project_id}/models/${project_id}.xml ./${project_id}_raw.xml
    
    # IMPORTANT: Copy the conventional model (e.g., iML1515.xml) to the new name
    cp ${conv_model_file} ./${project_id}_conv.xml
    
    # Copy the kcats and ecFVA files generated by gecko_protocol.m
    if [ -f "${project_id}/output/kcats.csv" ]; then
        cp ${project_id}/output/kcats.csv ./${project_id}_kcats.csv
    else
        echo "Reaction;Gene;kcat;Substrates" > ./${project_id}_kcats.csv
    fi
    
    if [ -f "${project_id}/output/ecFVA.csv" ]; then
        cp ${project_id}/output/ecFVA.csv ./${project_id}_ecFVA.csv
    else
        echo "rxnIDs;rxnNames;minFlux;maxFlux;ec-minFlux;ec-maxFlux" > ./${project_id}_ecFVA.csv
    fi
    """
}

process COMPARATIVE_ANALYSIS {
    label 'comparative_analysis'
    tag "comparative"
    publishDir "${params.outdir}/comparative_analysis", mode: 'copy'
    
    input:
    tuple val(ml1515_id), path(ec_ml1515), path(conv_ml1515), path(kcats_ml1515), path(ecfva_ml1515)
    tuple val(af1260_id), path(ec_af1260), path(conv_af1260), path(kcats_af1260), path(ecfva_af1260)
    path uniprot_file
    
    output:
    path "3A.png"
    path "3A.svg"
    path "3B.png"
    path "3C.png"
    path "3D.png"
    path "3E.png"
    path "3F.png"
    path "3G.png"
    path "3H.png"
    path "flux_significance_test_*.csv"
    path "pathways_progress*.csv"
    path "highlighted_data*.csv"
    path "kegg_hierarchy_*.json"
    
    script:
    '''
    # Prepare the workspace for comparative analysis
    
    # For iML1515
    cp ''' + conv_ml1515 + ''' ./iML1515.xml
    cp ''' + ec_ml1515 + ''' ./iML1515_ec_duplicated.xml
    cp ''' + kcats_ml1515 + ''' ./kcats.csv
    cp ''' + ecfva_ml1515 + ''' ./ecFVA.csv
    
    # For iAF1260
    cp ''' + conv_af1260 + ''' ./iAF1260.xml
    cp ''' + ec_af1260 + ''' ./iAF1260_ec_duplicated.xml
    cp ''' + kcats_af1260 + ''' ./kcats_iAF1260.csv
    cp ''' + ecfva_af1260 + ''' ./ecFVA_iAF1260.csv
    
    # UniProt file is already in the work directory with the correct name
    
    echo "=== Running comparative analysis ==="
    echo "Files in directory before analysis:"
    ls -la
    
    # Run the comparative analysis
    python ''' + projectDir + '''/bin/comparative_analysis.py
    
    echo "=== Files generated by comparative analysis ==="
    echo "Figures:"
    ls -la *.png *.svg 2>/dev/null || echo "No figure files found"
    echo ""
    echo "CSV files:"
    ls -la *.csv 2>/dev/null || echo "No CSV files found"
    echo ""
    echo "JSON files:"
    ls -la *.json 2>/dev/null || echo "No JSON files found"
    '''
}

process FIX_REVERSIBILITY {
    label 'ecGEM_preprocessing'
    tag "$project_id"
    
    input: 
    tuple val(project_id), path(ec_model), path(conv_model), path(kcats), path(ecfva)
    
    output: 
    tuple val(project_id), 
          path("${project_id}_fixed_rev.xml"), 
          path(conv_model),
          path(kcats),
          path(ecfva)
    
    script: 
    """
    # Pass through kcats and ecfva unchanged
    reversibility_fixer.py --conv-model-path $conv_model --ec-model-path $ec_model --output-path ${project_id}_fixed_rev.xml
    """
}

process CLEAN_REACTIONS {
    label 'ecGEM_preprocessing'
    tag "$project_id"
    
    input: 
    tuple val(project_id), path(fixed_model), path(conv_model), path(kcats), path(ecfva)
    
    output: 
    tuple val(project_id), 
          path("${project_id}_cleaned.xml"), 
          path(conv_model),
          path(kcats),
          path(ecfva)
    
    script: 
    """
    # Pass through kcats and ecfva unchanged
    reaction_cleaner.py --ec-model-path $fixed_model --output-path ${project_id}_cleaned.xml
    """
}

// Process for aligning EC model with EC Biolog data
process ALIGN_BIOLOG_EC {
    label 'ecGEM_preprocessing'
    tag "${project_id}_ec"
    
    input: 
    tuple val(project_id), path(ec_model), path(conv_model), path(kcats), path(ecfva)
    path biolog_csv_ec  // biolog_iML1515_ec_EXP.csv
    
    output: 
    tuple val(project_id), 
          path("${project_id}_aligned_ec.xml")
    
    script: 
    """
    # Align the ec model with ec Biolog data
    biolog_aligner.py --ec-model-path $ec_model --biolog-csv-path $biolog_csv_ec --output-path ${project_id}_aligned_ec.xml
    """
}

// Process for aligning CONVENTIONAL model with CONVENTIONAL Biolog data
process ALIGN_BIOLOG_CONV {
    label 'ecGEM_preprocessing'
    tag "${project_id}_conv"
    
    input: 
    tuple val(project_id), path(conv_model), path(kcats), path(ecfva)
    path biolog_csv_conv  // biolog_iML1515_EXP.csv
    
    output: 
    tuple val(project_id), 
          path("${project_id}_aligned_conv.xml")
    
    script: 
    """
    # Align the conventional model with conventional Biolog data
    biolog_aligner.py --ec-model-path $conv_model --biolog-csv-path $biolog_csv_conv --output-path ${project_id}_aligned_conv.xml
    """
}

// Modified DUPLICATE_MODEL process
process DUPLICATE_MODEL {
    label 'ecGEM_preprocessing'
    tag "$project_id"
    publishDir "${params.outdir}/${project_id}", mode: 'copy'
    
    input: 
    tuple val(project_id), 
          path(aligned_ec_model),     // Aligned ec model
          path(aligned_conv_model),   // Aligned conventional model
          path(kcats),
          path(ecfva)
    
    output: 
    tuple val(project_id), 
          path("${project_id}_final.xml"),           // Duplicated ecModel
          path("${project_id}_conventional_dup.xml"), // Duplicated conventional model
          path("${project_id}_kcats_final.csv"),
          path("${project_id}_ecFVA_final.csv")
    
    script: 
    """
    # 1. Create the duplicated ecModel (from aligned ec model)
    duplicate_model.py --model-path $aligned_ec_model --output-path ${project_id}_final.xml
    
    # 2. ALSO duplicate the aligned conventional model
    duplicate_model.py --model-path $aligned_conv_model --output-path ${project_id}_conventional_dup.xml
    
    # 3. Copy and rename the kcats file
    cp $kcats ./${project_id}_kcats_final.csv
    
    # 4. Copy and rename the ecFVA file
    cp $ecfva ./${project_id}_ecFVA_final.csv
    
    echo "=== Duplication complete ==="
    echo "Duplicated aligned ecModel: ${project_id}_final.xml"
    echo "Duplicated aligned conventional model: ${project_id}_conventional_dup.xml"
    """
}

// main.nf

workflow {
    ch_projects = Channel.fromList(project_list)
        .map { id, folder, cval, conv_name -> 
            [ id, file("${params.input_base}/${folder}"), cval, file("${params.input_base}/${folder}/${conv_name}") ] 
        }
    
    ch_lic = file(params.license)
    ch_uniprot = file(params.uniprot_file)
    
    // Separate channels for different file types:
    ch_biolog_ec = file(params.biolog_csv_ec)      // For ec model alignment: biolog_iML1515_ec_EXP.csv
    ch_biolog_conv = file(params.biolog_csv_conv)  // For conventional model alignment: biolog_iML1515_EXP.csv
    
    ch_medium_ec = file(params.medium_csv_ec)      // For ec training set: iML1515_ec_EXP.csv
    ch_medium_conv = file(params.medium_csv_conv)  // For conventional training set: iML1515_EXP.csv

    // Pipeline Execution Flow
    
    // 1. Run GECKO_PIPELINE for both models
    gecko_out = GECKO_PIPELINE(ch_projects, params.ec_params, ch_lic)
    
    // 2. Split outputs for comparative analysis
    gecko_out.branch {
        ml1515: it[0] == 'eciML1515'
        af1260: it[0] == 'eciAF1260'
    }.set { gecko_branches }
    
    // 3. Run COMPARATIVE_ANALYSIS immediately after GECKO_PIPELINE
    COMPARATIVE_ANALYSIS(gecko_branches.ml1515, gecko_branches.af1260, ch_uniprot)
    
    // 4. Continue with preprocessing pipeline for both models
    fixed_rev = FIX_REVERSIBILITY(gecko_out)
    cleaned   = CLEAN_REACTIONS(fixed_rev)
    
    // 5. Branch cleaned outputs for eciML1515 and eciAF1260
    cleaned.branch {
        ml1515: it[0] == 'eciML1515'
        af1260: it[0] == 'eciAF1260'
    }.set { branched_ch }
    
    // 6. For eciML1515: Align EC model with EC Biolog data
    aligned_ec_ml1515 = ALIGN_BIOLOG_EC(branched_ch.ml1515, ch_biolog_ec)
    
    // 7. For eciML1515: Extract conventional model and align with conventional Biolog data
    ml1515_conv_input = branched_ch.ml1515
        .map { project_id, ec_model, conv_model, kcats, ecfva ->
            [project_id, conv_model, kcats, ecfva]
        }
    
    aligned_conv_ml1515 = ALIGN_BIOLOG_CONV(ml1515_conv_input, ch_biolog_conv)
    
    // 8. Combine aligned models with original kcats/ecfva for eciML1515
    ml1515_kcats_ecfva = branched_ch.ml1515
        .map { project_id, ec_model, conv_model, kcats, ecfva ->
            [project_id, kcats, ecfva]
        }
    
    // Combine all three: aligned EC model, aligned conventional model, and kcats/ecfva
    combined_ml1515 = aligned_ec_ml1515
        .join(aligned_conv_ml1515)
        .join(ml1515_kcats_ecfva)
        .map { project_id, aligned_ec, aligned_conv, kcats, ecfva ->
            [project_id, aligned_ec, aligned_conv, kcats, ecfva]
        }
    
    // 9. For eciAF1260: Just pass through cleaned models (no Biolog alignment)
    af1260_for_duplication = branched_ch.af1260
        .map { project_id, ec_model, conv_model, kcats, ecfva ->
            [project_id, ec_model, conv_model, kcats, ecfva]
        }
    
    // 10. Final duplication step - DUPLICATES BOTH MODELS
    duplicate_out = DUPLICATE_MODEL(combined_ml1515.mix(af1260_for_duplication))
}